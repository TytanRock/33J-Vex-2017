#pragma config(Sensor, in1,    mobileGoal,     sensorPotentiometer)
#pragma config(Sensor, in2,    rightArm,       sensorPotentiometer)
#pragma config(Sensor, in3,    leftArm,        sensorPotentiometer)
#pragma config(Sensor, in4,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    chainPot,       sensorPotentiometer)
#pragma config(Motor,  port2,           leftDriveTrain, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mobileGoal2,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           chainArmMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftFourBar,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightFourBar,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mobileGoal1,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightDriveTrain, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "CoryLib.h"
#include "main.h"

task main()
{
	tGearBox leftDT;
	tGearBox rightDT;
	tGearBox left4Bar;
	tGearBox right4Bar;
	tGearBox claw;
	tGearBox chainArm;
	tGearBox mobile;

	tDriveTrain drive;

	tPositionalGearbox left4B;
	tPositionalGearbox right4B;
	tPositionalGearbox mobileArm;
	tPositionalGearbox clawControl;
	tPositionalGearbox chainControl;
///////////////////////////////////////////////////////////
	createGearBox(leftDT, leftDriveTrain);
	createGearBox(rightDT, rightDriveTrain);
	createGearBox(left4Bar, leftFourBar);
	createGearBox(right4Bar, rightFourBar);
	createGearBox(claw, clawMotor);
	createGearBox(chainArm, chainArmMotor);
	createGearBox(mobile, mobileGoal1, mobileGoal2);

	createDriveTrain(drive, leftDT, rightDT);

	createPositionalGearbox(left4B, left4Bar, 0, 0, 0);
	createPositionalGearbox(right4B, right4Bar, 0, 0, 0);
	createPositionalGearbox(mobileArm, mobile, 5, 1, 0);
	createPositionalGearbox(clawControl, claw, 0, 0, 0);
	createPositionalGearbox(chainControl, chainArm, 0, 0, 0);
///////////////////////////////////////////////////////////
	armState thisState = package;
	armPositions armPosition = armGround;
	clawPositions clawPosition = closed;
	chainPositions chainPosition = out;
	mobilePositions mobilePosition = mobileGround;
	float rightArmAngle;
	float leftArmAngle;
	float mobileAngle;
	float clawAngle;
	float chainAngle;
///////////////////////////////////////////////////////////
	bool idleArm;
	bool grabCone;
	bool raiseArm;
	bool indexCone;
	bool increaseConeCount;
	bool decreaseConeCount;
	bool mobileUp;
	bool mobileDown;

	bool lastGrabCone;
	bool lastIncreaseCount;
	bool lastDecreaseCount;

	bool clawManualOpen;
	bool clawManualClose;
	bool chainManualOpen;
	bool chainManualClose;

	int coneCount = 0;
	int armManual;
	int mbManual;

	float mobilePower = mobileGround;

	while(1)
	{
		lastGrabCone = grabCone;
		lastIncreaseCount = increaseConeCount;
		lastDecreaseCount = decreaseConeCount;

		rightArmAngle = convertAngle(SensorValue[rightArm], 0, 0);
		leftArmAngle = convertAngle(SensorValue[leftArm], 0, 0);
		mobileAngle = convertAngle(SensorValue[mobileGoal], -0.0548780487804878, 212);
		clawAngle = convertAngle(SensorValue[clawPot], 0, 0);
		chainAngle = convertAngle(SensorValue[chainPot], 0, 0);


		idleArm = (bool)vexRT[Btn7LXmtr2];
		grabCone = (bool)vexRT[Btn7UXmtr2];
		raiseArm = (bool)vexRT[Btn7RXmtr2];
		indexCone = (bool)vexRT[Btn7UXmtr2];
		increaseConeCount = (bool)vexRT[Btn6UXmtr2];
		decreaseConeCount = (bool)vexRT[Btn6DXmtr2];
		mobileUp = (bool)vexRT[Btn5UXmtr2];
		mobileDown = (bool)vexRT[Btn5DXmtr2];

		clawManualOpen = (bool)vexRT[Btn8UXmtr2];
		clawManualClose = (bool)vexRT[Btn8DXmtr2];
		chainManualOpen = (bool)vexRT[Btn8RXmtr2];
		chainManualClose = (bool)vexRT[Btn8LXmtr2];

		armManual = vexRT[Ch3Xmtr2];
		mbManual = -vexRT[Ch2Xmtr2];

		if(increaseConeCount && !lastIncreaseCount) coneCount++;
		if(decreaseConeCount && !lastDecreaseCount) coneCount--;
		if(idleArm) thisState = idle;

		switch(thisState)
		{
			case package:
			{
				chainPosition = out;
				armPosition = armGround;
				if(grabCone)
				{
					thisState = idle;
				}
				break;
			}
			case idle:
			{
				chainPosition = out;
				armPosition = idlePosition;
				clawPosition = open;
				if(grabCone && !lastGrabCone)
				{
					thisState = grabbing;
				}
				break;
			}
			case grabbing:
			{
				chainPosition = out;
				armPosition = idlePosition;
				clawPosition = closed;
				if(grabCone && !lastGrabCone || idleArm)
				{
					thisState = idle;
				}
				if(raiseArm)
				{
					thisState = (armState)(coneCount + 3);
				}
				break;
			}
			case cone0:
			{
				chainPosition = in;
				armPosition = l0;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone1:
			{
				chainPosition = in;
				armPosition = l1;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone2:
			{
				chainPosition = in;
				armPosition = l2;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone3:
			{
				chainPosition = in;
				armPosition = l3;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone4:
			{
				chainPosition = in;
				armPosition = l4;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone5:
			{
				chainPosition = in;
				armPosition = l5;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone6:
			{
				chainPosition = in;
				armPosition = l6;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone7:
			{
				chainPosition = in;
				armPosition = l7;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone8:
			{
				chainPosition = in;
				armPosition = l8;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case cone9:
			{
				chainPosition = in;
				armPosition = l9;
				thisState = (armState)(coneCount + 3);
				if(indexCone)
				{
					thisState = index;
				}
				break;
			}
			case index:
			{
				chainPosition = in;
				armPosition = idlePosition;
				clawPosition = open;
				break;
			}
		}

		if(mobileUp) mobilePosition = up;
		if(mobileDown) mobilePosition = mobileGround;

		mobilePower = ramp(mobilePosition, mobilePower);

		arcadeDrive(drive, vexRT[Ch3] ,vexRT[Ch1]);
		if(abs(armManual) < 10)
		{
			positionControl(left4B, armPosition - leftArmAngle);
			positionControl(right4B, armPosition - rightArmAngle);
		}
		else
		{
			stickManipulate(left4Bar, armManual);
			stickManipulate(right4Bar, armManual);
		}
		if(abs(mbManual) < 10)
		{
			positionControl(mobileArm, mobileAngle - mobilePower);
		}
		else
		{
			stickManipulate(mobile, mbManual);
		}
		if(clawManualOpen || clawManualClose)
		{
			buttonManipulate(claw, clawManualOpen, clawManualClose);
		}
		else
		{
			positionControl(clawControl, clawAngle - clawPosition);
		}

		if(chainManualOpen || chainManualClose)
		{
			buttonManipulate(chainArm, chainManualOpen, chainManualClose);
		}
		else
		{
			positionControl(chainControl, chainAngle - chainPosition);
		}
	}
}
